# 流运算符重载

cout：ostream类对象

cin：istream类对象

<<运算符能够使用在cout上，是因为ostream对<<运算符进行重载

cout << 1等价于cout.operator<<(1)，其函数本身的返回值就是ostream，而后我们对ostream继续输出(cout.operator<<(1)).operator<<("hello");由此形成循环调用

## 流运算符重载形式

```c++
friend ostream& operator<<(ostream& os, const Mint& x);
```

与别的重载形式不同的是，流运算符重载是通过友元的形式进行的

```c++
Mint operator-(int y){
	return Mint(this -> x + y);
}
```

主要区别在于减法和流运算符形式

- 减法：x - y
- 流运算符：cout << x

可以发现减法运算中减号左侧为调用对象，右侧为被调用对象；而流运算中流运算符左侧为被调用对象（ostream对象），右侧为调用对象。这造成了检测顺序上的反差。在减法中我们首先有x对象，然后x对象被减，因此调用减法重载，而后将y放入减法重载函数中作为形参。但流运算符不同的地方在于现有被调用对象然后才有调用对象，因此很明显，我们不能直接调用x对象的<<流运算符重载。

使用的方式是友元函数的方式来调用。

实际上关于运算符重载本身就有两种方式，一种是成员函数的调用，用于调用对象出现在被调用对象之前的情况；还有一种是友元函数的调用，用于调用对象出现在被调用对象之后的情况。

友元函数在发现x为调用对象之后调用Mint类型的友元函数，按照顺序将cout和x放入友元函数形式参数中并且输出。

> 实际上所有符号重定义都可以通过友元函数来实现