# All-in-One Graph Processing in RDBMSs Revisited

- 为了将图操作兼容到关系型数据库中提出了4种操作：MM-join，MV-join，反连接，更新式并集，这四种操作都能由关系代数操作以及聚合和加和操作来完成，
  - MM-join, MV-join

    矩阵和矩阵之间的连接操作，矩阵和向量之间的连接操作

  - 反连接

    移除图中不必要的节点

  - 更新式

    处理值的更新

- 顶点中心编程模式

  顶点中心编程模式中，每个顶点通过它相邻的节点不断交互以更新结点，最后得到最终答案

  经典的应用案例有PageRank算法

- 递归sql算法关注点

  - 支持图算法并且能够递归sql查询
  - 递归sql查询能够得到唯一的答案

- 非单调递归sql查询

- 传递闭包

  在一张图中假设一个结点$u$存在一条路径能够到达另一个结点$v$，那么这两个结点之间应该连上一条路径

- 递归查询中否定的使用

  - 什么情况下能够使用否定？

    不破坏递归查询的结构即可否定

  - 什么情况下不能够使用否定？

    否定若破坏递归查询结构不可否定

- MM-join MV-join

  - 半环的定义

    一种有两种运算的群，分别记为$\oplus$以及$\otimes$

    - 对于$\oplus$

      结合性，交换性以及幺元

    - 对于$\otimes$

      结合性，幺元

    - $\otimes$对$\oplus$具有分配性

  - M和V的意义

    M邻接矩阵表示为边权重，V向量表示为点权重

    MM-join即为两个邻接矩阵相乘，MV-join即为邻接矩阵和点向量相乘

    在图论中我们通过定义自己的半环运算法则，则能够通过矩阵运算来对我们的操作规范化
    
    $$
    A\bowtie_{A.T=B.F}^{\oplus(\odot)}B=_{A.F,B.T}\mathcal{G}_{\oplus(\odot)}(A\bowtie_{A.T=B.F}B)
    $$
    
    - $A\bowtie_{A.T=B.F}^{\oplus(\odot)}B$
    
      上标$\oplus(\odot)$表示半环运算，下表$A.T=B.F$表示连接条件，即为$A$矩阵指向点和$B$矩阵起始点相同，$\bowtie$表示连接操作，我们使用$A\bowtie_{A.T=B.F}^{\oplus(\odot)}B$来表示$MM-join$连接
    
    - $_{A.F,B.T}\mathcal{G}_{\oplus(\odot)}(A\bowtie_{A.T=B.F}B)$
    
      $A.F,B.T$表示聚合操作之后$A.F$为起始点，$B.T$为终点，$\mathcal{G}_{\oplus(\odot)}$表示聚合操作，聚合的对象为$A\bowtie_{A.T=B.F}B$
    
      对于等号右边的内容我们能够理解为连接之后再聚合，实际上这能够用最短路径算法来理解
    
      ![1](.\pic\1.png)
    
      $MM-join$实际上是$AB$两个矩阵根据定义的半环计算规则进行矩阵乘法
    
      用最短路算法来表示就是将$\oplus$定义为$min$运算，而$\odot$定义为$+$运算
    
      在论文中$\odot$运算被理解为两条路径的加和操作，而$\oplus$运算被理解为两条路径的聚合操作，加和操作是将两条路径合并为一条路径，而聚合操作是将多条路径的信息合并为唯一一条路径。在最短路算法中我们通过加和操作生成多条路径，而后通过聚合操作选取其中的最短路。
    
    $MV-join$类似
    
  - $MM-join$的实现

    我们假设$MM$的两个矩阵分别为$A$和$B$，$A$和$B$实际上对应两个数据表，我们将其命名为$A(F,T,W_A)$以及$B(F,T,W_B)$，将我们的目标矩阵命名为$C$，写作$C(F,T,W_C)$，我们使用连接和聚合操作实际上能够完成矩阵相乘的操作

    首先我们使用内连接分别筛选$A.T$和$B.F$相同的记录，并且筛选$A.F$和$B.T$作为$C.F$和$C.T$，同时计算$W_A\odot W_B$作为$W_C$，但是现在有个问题就是结果中存在大量$C.F$和$C.T$相同的情况，我们通过聚合操作来解决问题

    实际上这个过程依然类似于矩阵乘法
    $$
    C_{ij}=\sum A_{ik}B_{kj}
    $$
    

- anti-join  $\bar\ltimes$

  移除图中不必要的结点和边

- union-by-update

  更新式并集，更新矩阵或者向量中的值

  假设有$R(A,B)$和$S(A,B)$这两个关系，假设$r$为$R$中的一个元组，$s$为$S$中的一个元组，现在我们来研究一个更新，即为$R\uplus_AS$。更新中匹配的条件即为$r.A=s.A$

  - 匹配成功使用$S$中的记录来覆盖$R$中的记录
  - 倘若$r,s$没有匹配成功，那么$r,s$都直接保存在结果里
  - **不允许**多个$s$匹配同一个$r$

- 关系型数据库中的关系

  数学上来说关系就是多个属性域（例如身高、体重、人名、性别等等）的笛卡尔积的子集，我们能够理解的是多个属性域的笛卡尔积实际上并没有意义，而其子集则可以认为是有意义的，也就是我们所说的关系——多个属性域之间的关系

  关系型数据库中的**关系**表现形式即为数据表，关系代数的操作实际则是关系型数据库的操作

- 合取查询 析取查询

  合取查询即为and逻辑 析取查询即为or逻辑

- 逻辑编程范式

  将计算机视作逻辑推理过程

- 膨胀性语言 非膨胀性语言

  - 膨胀性语言：保证在多项式规模时间内终止

    赋值语句在原有的基础上增加内容，赋值之后被赋值的变量保存原有的值并且加上需要赋的值

  - 非膨胀性语言：仅保证在多项式规模的空间上运行

    赋值语句为破坏性赋值，赋值之后将原有的内容覆盖

- while语句

  ```
  while change do
  begin
  (循环体)
  end
  ```

  循环过程中只要对某个关系发生了改变就会继续循环
  
- 不动点

  递归过程中存在一个状态，使得这个状态之后所有的递归状态与其本上相同，这个状态就是我们所说的不动点

- 更新式并集和非膨胀语义

  膨胀式语义使用传统并集，非膨胀式语义使用更新式并集

  膨胀式语义中赋值是在原有的基础上增加内容，因此使用传统并集

  非膨胀式语义赋值采用破坏性赋值，需要覆盖原有的内容，因此采用更新式并集

- 使用MM-join MV-join 反连接 更新并集的方式来实现图论算法

  - BFS

    初始情况下，使用1来表示图中边存在，使用1表示当前结点被访问过，初始的点向量中有n个值对应n个点，其中只有初始点的对应的值为1其余都是0
    $$
    V\leftarrow\rho_V(E\bowtie_{T=ID}^{max(vw*ew)} V)
    $$
    在当前的计算方式中，我们依然采用了半环矩阵的计算方式，将乘法定义为$\odot$（也就是数据库中的连接），将$max$定义为$\odot$（也就是数据库中的聚合），使用$MV-join$的方式来连接，并将结果更新式赋值到$V$向量中

    





