# 最短路算法

## bellman-ford算法

```c++
// Bellman-Ford 模板（1-based）
// 复杂度：O(n*m)
// 功能：求单源最短路；可检测从源点可达的负环
#include <bits/stdc++.h>
using namespace std;

struct Edge {
    int u, v;
    long long w;
};

const long long INF = (long long)4e18;

struct BFResult {
    vector<long long> dist;  // dist[1..n]
    vector<int> parent;      // parent[1..n] 用于重建路径
    bool hasNegCycle;        // 是否存在从源点可达的负环
};

BFResult bellman_ford(int n, const vector<Edge>& edges, int s) {
    vector<long long> dist(n+1, INF);
    vector<int> parent(n+1, -1);
    dist[s] = 0;

    bool changed = false;
    for (int i = 1; i <= n-1; ++i) {
        changed = false;
        for (const auto& e : edges) {
            if (dist[e.u] == INF) continue;
            if (dist[e.u] + e.w < dist[e.v]) {
                dist[e.v] = dist[e.u] + e.w;
                parent[e.v] = e.u;
                changed = true;
            }
        }
        if (!changed) break; // 提前退出
    }

    bool hasNegCycle = false;
    for (const auto& e : edges) {
        if (dist[e.u] == INF) continue;
        if (dist[e.u] + e.w < dist[e.v]) {
            hasNegCycle = true;
            break;
        }
    }

    return {dist, parent, hasNegCycle};
}
```

对所有边进行最多$|V|-1$次松弛，即可得到最短路径

## dijkstra算法

```c++
#include <bits/stdc++.h>
using namespace std;

const long long INF = (long long)4e18;

struct DKResult {
    vector<long long> dist; // 最短距离
    vector<int> parent;     // 前驱节点
};

DKResult dijkstra_naive(int n, const vector<vector<long long>>& w, int s) {
    vector<long long> dist(n+1, INF);
    vector<int> parent(n+1, -1);
    vector<char> vis(n+1, 0);

    dist[s] = 0;
    for (int i = 1; i <= n; ++i) {
        // 1. 选出未访问的 dist 最小的顶点
        int u = -1;
        long long minDist = INF;
        for (int v = 1; v <= n; ++v) {
            if (!vis[v] && dist[v] < minDist) {
                minDist = dist[v];
                u = v;
            }
        }
        if (u == -1) break; // 剩下的不可达
        vis[u] = 1;

        // 2. 用 u 松弛其他点
        for (int v = 1; v <= n; ++v) {
            if (w[u][v] < INF && dist[u] + w[u][v] < dist[v]) {
                dist[v] = dist[u] + w[u][v];
                parent[v] = u;
            }
        }
    }
    return {dist, parent};
}
```

相较于bellman-ford，dijkstra使用了贪心的思想，只松弛被选出点相连的边，但因为贪心算法实际上引入了一个假设存在的最高主宰能够选择哪些点松弛，哪些不用，这实际上不适用于分布式环境