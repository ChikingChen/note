# 外部排序

假设有$1e20$个$int$变量需要排序，很明显我们无法将这些$int$变量全部读入内存并排序，我们的办法只能是将其大部分放在外存中仅将小部分放入内存中排序，这就涉及到外存读入读出的问题，如何减少外存读入读出进而减少$I/O$时间这是一个需要考虑的问题

## 外部排序基本方式

将整个数组划分为多个归并段，将每个归并段标记为$R1,R2\ldots$，取出$R1,R2$放入内存中使用归并排序将两个归并段归并为一个对象$R1^{'}$将这个对象写入输出归并段$R1^{'}$，简而言之就是将$R1,R2$从外存中读入内存而后利用归并排序将二者归并得到$R1^{'}$再放回外存，循环往复得到答案

我们可以理解的是一趟归并需要将所有的数据全部读入又写出一次，假设序列长度为$n$，那么一次序列的排列需要$2n$次$IO$，因而我们得出结论，增加归并路数，减少排列趟数即可减少$IO$总数（详细看王道$355$页）

## 败者树

假设我们使用$k$路归并，我们可以理解如果我们归并一个数字需要比较$k-1$个关键字，归并$n$个数字则需要比较$(n-1)*(k-1)$次，那么就会出现一个现象也就是说归并的路数越多内部排序的比较次数也就越多，总效率由此下降，因而我们引入败者树来解决这个问题

败者树整体来讲是一个树形选择结构，本质来讲就是将$n$个段的记录两两比较，相当于打擂台，输的的人留在原地（也就是写在败者树上），赢的人继续晋级，最后的赢家就是归并的结果

败者树主要存在两个问题：为什么是输的人写在败者树上？写在败者树上的是败者的关键字还是败者来自的归并段的编号？

这两个问题的探讨根源在于其比较反常识而且其反常识的背后有着逻辑的支撑。

### 为什么是输的人写在败者树上？

我们可以这么说败者树上只有赢家会被读走（也就是对应的归并段的第一个记录）而所有在某个地方失败的输家都将停留在原地，因此我们可以这么认为如果被读的归并段的新的关键字需要重新竞技，我们可以认为其一定是与上一轮的输家竞技（因为赢的人已经被读走了），新的关键字输了则由胜者代替新的关键字继续向上竞赛，从而形成了一种只有输的人写在树上的现象

### 为什么写在败者树上败者的是归并段编号而不是败者的关键字具体数值？

这就考虑到我们整个败者树的目的了，即我们是要从对应的归并段中将数据读走放入新的归并段，如果我们仅仅是在败者树上标记具体数值那么我们就不知道败者树应该从哪里将记录取走

### 总结

通过比较简单的数学计算我们可以得到使得我们能够无关归并段数来完成归并

## 初始归并段的产生

外部排序可以认为是一种归并排序的魔改，先前的败者树解决了归并排序中如何选择归并元素的问题，现在我们将讲述如何生成初始归并段的算法——置换选择算法

置换选择算法将数据分为三个部分分别为待排文件$FI$，输出文件$FO$以及内存工作区$WA$，前二者使用空间较大，后者于内存中工作使用空间较小。假设$WA$的空间为$n$。先从$FI$中取出$n$个元素放入$WA$中，从$WA$中选取最小值放入$FO$中，而后再按序从$FI$中取出元素放入$WA$中，将$WA$中的元素与$FI$中最后一个元素比较选取$WA$中大于它且最小的数据继续放入$FI$中如此循环往复直到$WA$中没有元素符合条件。

## 最佳归并树

我们可以理解使用置换选择算法将产生大量长短不一的归并段，利用最佳归并树（哈夫曼树思想）即可生成最佳归并序列使得$IO$次数最少

$IO$次数与归并序列长度正相关，因此可以直接利用哈夫曼树的思想来解决问题

## 总结

外部排序与内部排序的区别在于前者的效率将受到外存$IO$速率的影响，这就要求前者需要考虑如何减少$IO$次数，关于这个命题我们提出了增加归并路数以及使用败者树算法的策略。其次为了产生合适的归并段我们选择使用置换选择算法来产生有序归并段，大大提升了成规模的归并段产生的效率。最后，利用哈夫曼树的思想构建最佳归并树，使得面对长短不一的归并段时候我们能够构建出最优的归并策略。