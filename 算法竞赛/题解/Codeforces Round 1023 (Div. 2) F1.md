# [Codeforces Round 1023 (Div. 2)](https://codeforces.com/contest/2107) F1

```c++
#include <bits/stdc++.h>
using namespace std;

int main(){
    int t; cin >> t;
    while (t--){
        int n; cin >> n;
        
        vector <int> a(n + 1);
        for (int i = 1; i <= n; i++){
            cin >> a[i];
        }
        
        vector <long long> dp(n + 1, 1e18);
        dp[n] = 0;
        
        for (int i = n - 1; i >= 0; i--){
            int p = i + 1;
            for (int j = i + 1; j <= n; j++) if (a[j] < a[p]){
                p = j;
            }
            
            for (int j = p; j <= n; j++){
                dp[i] = min(dp[i], dp[j] + 2 * (j - p) + 1LL * (j - i) * a[p] + (p - i - 1));
            }
        }
        
        cout << dp[0] << "\n";
    }
    return 0;
}
```

p 最小元素位置，以$a_p$成本超过$1,2,\ldots,p$，假设$a_i(1\leq i <p)$大于等于$a_p+1$

在后缀$q$（$q > p$）中使用$a_p$超车，因此我们讲问题转化为子问题$a[q+1,n]$

原问题是考虑$a[1, n]$的超车问题，现在我们关注于最小值$a_p$，关于$q_1<p$所有的$i\in[1, p - 1]$如果要超车，使用$a_p$一定是最小的；关于$q_2>p$依然存在使用$a_p$来超车的可能性，因此我们能够认为，对于最小值$a_p$存在一个可能的区间$[1, q_2]$这个范围内，都要使用$a_p$进行超车。因此我们只用关注$[q_2+1, n]$这个范围内超车的开销。

我们设置$dp[i]$为$[i, n]$的答案，$p$为$a[i,n]$中最小值的位置。

最后的计算方式是
$$
dp[i]=\min_{j=p}^n(dp[j]+2*(j-p)+(j-i)*a[p]+(p-i-1))
$$
$dp[i]$的意义是的从跟在$n$后面到跟在$i$后面位置转换的最小开销，我们能够理解的$dp[i]$的计算方式是从$dp[j](p\leq j\leq n)$转移过来，$p$是$[i+1,n]$范围内$a$的最小值。

- 为什么要关注$a[p]$这个最小值

  因为我们考虑到$a[p]$他在$[i+1,n]$之间他是最小的，因此我们在处理$[i+1,p]$的过程中，我们一定会使用$a[p]$作为超越的数值，从$dp[p]$处开始转移一定有可能是$dp[i]$的最优解之一。那么如果我们从$dp[p+1]$处开始转移，会不会有可能存在相较于$dp[p]$处转移更加好的方案？实际上不可能，因为$dp[p+1]$一定是从$dp[p]$转移过来的。

因此这个问题就转化为了我们上面提到的在$[q_1,q_2]$这个区间内超车的问题，我们首先枚举$q_1$，这个是我们超车的目的地，范围为$[0,n-1]$，而后我们查找$[q_1+1,n]$这个范围内的最小值，因为如果我们要超车到达$q_1$那么我们一定要使用这个最小值来超车（原因见上），当然，贪心地来看，如果我们最小值所在的位置后面几位也有可能要用最小值来超车，但是后面几位，我们无法确定，因此我们需要枚举$q_2$，$q_2$范围为$[p,n]$

如何转移？
$$
dp[i]=\min_{j=p}^n(dp[j]+2*(j-p)+(j-i)*a[p]+(p-i-1))
$$
$j$转移到$i$的花费主要分两部分，超车的费用以及移动的费用

- 超车的费用

  原来是跟在$j$后面，后来是跟在$i$后面，这个过程中全部是使用$a[p]$进行超车，因此花费为$(i-j)*a[p]$

- 移动的费用

  原来是位于$p$上面，然后位于$j$上面，然后位于$i$上面，其中的花费为$(j-p)+(j-i - 1)$（跟在$i$的屁股后面）